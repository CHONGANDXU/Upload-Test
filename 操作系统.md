# 第一章 引论
## 1.1 操作系统的概念

- 定义
>操作系统是计算机系统中的系统软件，是能有效地组织和管理计算机系统中的硬件和软件资源，合理地组织计算机工作流程，控制程序的执行，并向用户提供各种服务功能，使得用户能够方便地使用计算机，使整个计算机系统能高效运行的一组程序模块的集合。
（1）“有效”主要指操作系统在管理资源方面要考虑到系统运行效率和资源的利用率，要尽可能地提高处理机的利用率，让它尽可能少地空转，其他的资源，例如内存、硬盘，则应该在保证访问效能的前提下尽可能地减少浪费的空间等。
（2）“合理”主要是指操作系统对于不同的用户程序要“公平”，以保证系统不发生“死锁”和“饥饿”的现象。
（3）“方便”主要是指人机界面方面，包括用户使用界面和程序设计接口两方面的易用性、易学性和易维护性。

- 作用
    1. 操作系统要管理计算机系统中的各种资源，包括硬件及软件资源
    2. 操作系统要为用户提供良好的界面

    >资源管理者——有效
    >
    >提供服务——方便使用
    >
    >对硬件机器的拓展——拓展性

- 目标
    1. 方便性
    2. 有效性
    3. 可扩充性
    4. 开放性

## 1.2 操作系统的形成与发展
### 1.2.1 操作系统的形成
- 批处理程序（单道和多道）
    - 工作方式
    1. 用户将作业交给操作员
    2. 系统操作员将许多用户的作业组成一批作业，输入到计算机系统中，在系统中形成一个自动转接的连续作业流
    3. 启动操作系统
    4. 系统自动、依此执行每个作业
    5. 由操作员将作业结果交给用户
    - 追求目标：提高资源利用率、增加作业处理吞吐量

- 分时系统
    1.  分时系统的产生。如果说，推动多道批处理系统形成和发展的主要动力是提高资源利用率和增加系统吞吐量，那么，推动分时系统形成和发展的主要动力则是用户的需要。
    用户需要表现在以下几个方面：
        - 人机交互
        - 共享主机
        - 便于用户上机

    2. 时间片。操作系统将CPU的时间划分成若干个片段，称为时间片。

    >操作系统以时间片为单位，轮流为某个终端用户服务，每次服务一个时间片。
    >特点：利用人的错觉，使用户感觉不到计算机在服务其他人。

    >追求目标：及时响应（依据是响应时间）
    >响应时间：从终端发出命令到系统给予回答所经历的时间

- 实时操作系统
    - 定义：
        - “实时”：表示“及时”、“即时”
        - “实时系统”：是指使系统能及时（或即时）响应外部事件的请求，在规定的严格时间内完成该事件的处理，并控制所有实时任务协调一致地运行。
    - 分类
        - 第一类（实时过程控制）：工业控制、航空、军事控制
        - 第二类（实时信息处理）：电讯（自动交换机）、银行、飞机订票、股票行情

### 1.2.2 操作系统的进一步发展
- 网络操作系统
    计算机网络可以定义为一些互联的自主计算机系统的集合。所谓自主计算机是指计算机具有独立处理能力；而互联则是表示计算机之间能够实现通信和相互合作。可见，计算机网络是在计算机技术和通信技术在高度发展的基础上相互结合的产物。
    1. 计算机网络的类型。
        - 按网络拓扑结构分类。根据网络拓扑结构的不同，可将网络分成以下5类：
            - 星形网络。每一个远地结点通过一条单独的传输线路与中心点连接，即采用点-点连接方式，使网络呈现星形。
            - 树形网络。将一个多级星形网络按层次排列便形成树形网络。树的根，即网络的最高层，是中央处理机，树的叶，即网络的最底层，为终端式个人计算机。
            - 总线形网络。将若干个结点通过一条高速总线互联起来所形成的网络。采用广播方式，即由一个结点发出的信息可被总线上的所有结点接收。
            - 环形网络。采用高速点-点信道，将各结点连接成环形，网络中的信息流是定向的，由一个源结点发出的信息将绕环传输一周后返回源结点。
            - 网状形网络。各个结点间通过点-点连接，形成不规则的形状，结点之间通常都有多条通路。

        - 按网络地理范围分类。按网络所覆盖地理范围的大小，可把计算机网络分成以下两类：
            - 广域网（WAN）。这种计算机网络所跨越的距离通常为数百千米到数千千米，甚至是上万千米；网络所覆盖的范围可以为一个地区或一个国家，乃至几大洲，其传输速率可达到数Mbit/s；网络中的通信设施属国家所有。
            - 局域网（LAN）。这种计算机网络所跨越的距离通常为几十米至数千米；网络所覆盖的范围为一栋楼或一个单位；其传输速率较高，可达到100Mbit/s；网络设施属单位所有。

    2. 网络操作系统的工作模式。
        - 客户机/服务器（Client/Server，C/S）模式。该模式是在20世纪80年代发展起来的，目前仍广为流行。网络中的各个站点可分为以下两大类。
            - 服务器。它是网络的控制中心，其任务是向客户机提供一种或多种服务。服务器可有多种类型，如提供文件/打印服务的文件服务器、提供数据库服务的数据库服务器等。在服务器中包含了大量的服务程序和服务支撑软件。
            - 客户机。这是用户用于本地处理和访问服务器的站点。在客户机中包含了本地处理软件和访问服务器上服务程序的软件接口。C/S模式具有分布处理和集中控制的特征。
    
        - 对等模式。采用这种模式的操作系统的网络中，各个站点是对等的。它既可作为客户机去访问其他站点，又可作为服务器向其他站点提供服务。在网络中既无服务处理中心，也无控制中心。或者说，网络的服务和控制功能分布于各个站点上。可见，该模式具有分布处理及分布控制的特征。

    3. 网络操作系统的功能。网络操作系统应具有下述5方面的功能：
    - 网络通信
    - 资源管理
    - 网络服务
    - 网络管理
    - 互操作能力

- 分布式操作系统
    1. 分布式系统。在分布式系统中，系统的处理和控制功能分散在系统的各个处理单元上。系统中的所有任务也可动态地被分配到各个处理单元中，使它们并行执行，实现分布处理。可见，**分布式系统最基本的特征是处理上的分布**。而**处理分布的实质是资源、功能、任务和控制都是分布的**。
    2. 分布式操作系统与网络操作系统的比较。在分布式系统上配置的操作系统，称为分布式操作系统，它虽与网络操作系统有许多相似之处，但两者各有其特点。下面从5个方面对两者进行比较：
        1. 分布性。分布式操作系统不是集中地驻留在某一个站点中，而是较均匀地分布在系统的各个站点上，因此分布式操作系统的处理和控制功能是分布式的。计算机网络虽然具有分布处理功能，然而网络的控制功能则大多集中在某个（些）主机或网络服务器中，或者说控制方式是集中式。
        2. 并行性。在分布式处理系统中，具有多个处理单元，因此，分布式操作系统的任务分配程序可将多个任务分配到多个处理单元上，使这些任务并行执行，从而加速任务的执行。而在计算机网络中，每个用户的一个或多个任务通常都在自己（本地）的计算机上处理，因此在网络操作系统中通常无任务分配功能。
        3. 透明性。分布式操作系统通常能很好地隐藏系统内部的实现细节。对于网络操作系统，虽然它也具有一定的透明性，但主要是指在操作实现上的透明性。
        4. 共享性。在分布式系统中，分布在各个站点上的软、硬件资源可供全系统中的所有用户共享，并能以透明方式对它们进行访问。而网络操作系统虽然也能提供资源共享，但所共享的资源大多是设置在主机或网络服务器中。而在其他计算机上的资源则通常仅由使用该机的用户独占。
        5. 健壮性。由于分布式系统的处理和控制功能是分布的，因此任何站点上的故障都不会给系统造成太大的影响；加之当某设备出现故障时，可通过容错技术实现系统重构，从而仍能保证系统的正常运行，因而系统具有健壮性，即具有较好的可用性和可靠性。而现在的网络操作系统的控制功能大多集中在主机或服务器中，这使得系统具有潜在的不可靠性，此外，系统的重构功能也较弱。

## 1.4 操作系统的功能和特征
1. 功能：
    - 处理机管理功能：进程控制、进程同步、进程通信、调度   
    - 存储器管理的功能：内存分配、内存保护、地址映射、内存扩充
    - 设备管理的功能：缓冲管理、设备分配、设备处理、设备独立性和虚拟设备
    - 文件管理的功能：文件存储空间的管理、目录管理、文件的读写管理和存取控制
    - 用户接口：命令接口、程序接口、图形接口

2. 特征：
    - 并发：指处理多个同时性活动的能力
    由于并发将会引起很多的问题：活动切换、保护、相互依赖的活动间的同步
    在计算机系统中同时存在多个程序在运行，单CPU上
        - 宏观上：这些程序同时在执行
        - 微观上：任何时刻只有一个程序在执行，即这些程序在CPU上是轮流执行的

    - 并行：与并发相似，多指不同程序同时在多个硬件部件上执行

    - 共享：操作系统与多个用户的程序共同使用计算机系统中资源（共享有限的资源）
    操作系统要对系统资源进行合理的分配和使用
    资源在一段时间内交替被多个进程所用
        - 互斥共享：打印机
        - 同时共享：可重入代码、磁盘文件
        - **问题：资源分配难以达到最优化，如何保护资源**
    
    - 虚拟：
        - 一个物理实体映射为若干个对应的逻辑实体——分时或分空间
        - 虚拟是操作系统管理系统资源的重要手段，可提高资源利用率
        1. CPU——每个进程的“虚处理机”
        2. 存储器——每个进程都有独立的虚拟地址空间（代码+数据+堆栈）
        3. 显示设备——多窗口或虚拟终端

    - 随机（异步性）：操作系统必须随时对以不可预测的次序发生的事件进行响应并处理
        - 进程的运行速度不可预知：多个进程并发执行，“走走停停”，无法预知每个进程的运行推进的快慢
        - 难以重现系统在某个时刻的状态（包括重新运行中的错误）

# 第二章 操作系统的硬件环境

## 2.1 中央处理机

### 2.1.1 处理机的构成与基本工作方式
- 处理器由运算器、控制器、一系列的寄存器以及高速缓存构成

- 两类寄存器：
    - 用户可见寄存器：高级语言编译器通过优化算法分配并使用它，以减少程序访问内存次数
    - 控制和状态寄存器：用户控制处理器的操作，通常由操作系统代码使用；在某种特权级别下可以访问、修改
    常见的控制和状态寄存器：
    程序计数器（PC）：记录将要取出的指令地址
    指令寄存器（IR）：记录最近取出的指令
    程序状态字（PSW）：记录处理器的运行状态，模式、条件码、控制位等信息

- 指令执行的基本过程：程序的执行就是由不断取指令和执行指令的指令周期组成的。
    开始->取下一条指令（取指周期）->执行周期（执行周期）->停止

### 2.1.2 处理机的状态
1. 特权指令和非特权指令
- 特权指令：只能由操作系统使用，用户程序不能使用的指令
- 非特权指令：用户程序可以使用的指令
```
下列哪些是特权指令？哪些是非特权指令？
特权：启动I/O  内存清零  修改程序状态字  设置时钟  允许/禁止中断  停机
非特权：控制转移  算数运算  访管指令
```

2. 处理机的状态
操作系统需要两种CPU状态：管态和目态  特权态和普通态
内核态：运行操作系统程序
用户态：运行用户程序

## 2.2 存储系统 

### 2.2.1 存储器的类型
RAM：随机访问存储器
ROM：只读存储器

### 2.2.2 存储器的层次结构
计算机存储系统的设计主要考虑3个问题：容量、速度和成本
提高存储系统效能的关键点就在于  **程序的存储访问局部性原理**

![](\pictures\存储体系结构.jpg)

## 2.3 缓冲技术与中断技术

### 2.3.1 缓冲技术
- 引入原因
    概念：缓冲区是硬件设备之间进行数据传输时，专门用来暂存这些数据的一个存储区域。
    用途：缓冲技术一般有3种用途
        1. 用在处理机与内存之间的
        2. 用在处理机和其他外围设备之间的
        3. 用在设备与设备之间的通信上的。
    目的：为了解决部件之间速度不匹配的问题。

- 类型
    单缓冲、双缓冲、多缓冲（Cache）

### 2.3.2 中断技术
- 中断/异常机制：是现代计算机系统的核心机制之一(硬件和软件相互配合而使计算机系统得以充分发挥能力)
    >硬件该做什么事？——中断/异常响应
    >>捕获中断源发出的中断/异常请求，以一定的方式响应，将处理器控制权交给特定的处理程序
    >
    >软件该做什么事？——中断/异常响应程序
    >识别中断/异常类型并完成相应的处理
    
    中断/异常 对于 操作系统  
    相当于 “引擎” 对于 “飞机”  或者  “发动机” 对于 “汽车”

    **操作系统是由 “中断” 驱动 或 “中断事件” 驱动**

    主要作用：
    1. 及时处理设备发来的中断请求
    2. 可使OS捕获用户程序提出的服务请求
    3. 防止用户程序执行过程中的破坏性活动

- 中断/异常的概念：CPU对系统发生的某个事件作出的一种反应
    CPU暂存正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序。
    - 特点：
        - 随机发生
        - 自动处理
        - 可恢复

中断依据中断事件发生和处理是否是异步的可以分为异步中断和同步中断。
异步中断简称中断（Interrupt），而同步中断一般称为异常（Exception）。

# 第三章 进程与进程管理

## 3.1 进程的引入

程序顺序执行：程序在执行时，必须按照某种先后次序逐个执行，仅当前一操作执行完后，才能执行后续操作（**在计算机操作系统中只有一个程序在运行，这个程序独占系统中的所有资源，其执行不受外界影响**）

程序并发执行：为增强系统处理能力和提高资源利用率，现代操作系统普遍采用多道程序设计技术，其重要特点就是程序并发执行。

## 3.2 进程

### 3.2.1 进程的概念
>定义：
>进程是具有独立功能的可并发执行的程序关于某个数据集合上的一次运行活动，是系统进行资源分配的调度的独立单位（又称 **任务**）
>- 程序的一次执行过程
>- 是正常运行程序的抽象
>- 将一个CPU变换成多个虚拟CPU
>- 系统资源以进程为单位分配，如内存、文件等，每个都有独立的地址空间
>- 操作系统将CPU调度给所需要的进程

>程序与进程的区别与联系:
>>区别:
>>>- 程序是指令的有序集合，其本身没有任何运行的含义，是一个
静态的概念。而进程是程序在处理机上的一次执行过程，它是
一个动态的概念。
>>>- 进程是系统进行资源分配和调度的一个独立单位，程序则不是。
>
>>>- 进程与程序的对应关系：通过多次执行，一个程序可对应多个
进程；通过调用关系，一个进程可包括多个程序。
>>>- 程序可以作为一种软件资料长期存在，而进程是有一定生命期
的。程序是永久的，进程是暂时的。
>>>- 进程和程序组成不同：进程是由程序、数据和进程控制块三部
分组成的。
>>联系: **进程是程序的运行**
>>例子：光盘（程序） 放光盘的活动（进程）

>进程的特征
>1. 动态性：进程是程序的执行，同时进程有生命周期。
>2. 并发性：多个进程可同存于内存中，能在
一段时间内同时执行。
>3. 独立性：资源分配和调度的基本单位
>4. 异步性：并发进程间存在制约关系，造成程序执行速度不可预测性，必须对进程的并发执行次序、相对执行速度加以协调。
>5. 结构特征：进程由程序段、数据段、进程控制块三部分组成。

### 3.2.2 进程的基本状态及其转换
1. 进程的3种基本状态
    1. 就绪状态：进程已分配到除CPU以外的所有必要资源
    2. 执行状态：进程正在执行
    3. 阻塞状态：进程因发生某些事件（例如I/O请求、申请缓冲空间）而暂停执行。也称为“等待”或“睡眠”状态。

2. 进程状态的转换
    1. 就绪->执行：分配了CPU
    2. 执行->阻塞：发生等待事件（例如请求OS服务，对资源的访问尚不能进行，等待I/O请求，申请缓冲空间，等待另一进程提供信息）
    3. 执行->就绪：分时系统中，正在执行的进程因时间片用完而被暂停执行；抢占调度方式中，高优先级进程抢占正在执行的低优先级进程的CPU
    4. 阻塞->就绪：等待事件已经发生，例如I/O请求完成

### 3.2.3 进程控制块（PCB）
- PCB：
    - 又称 **进程描述符** 、 **进程属性**
    - 操作系统用于管理控制进程的一个专门数据结构
    - 记录进程的各种属性，描述进程的动态变化过程

- PCB是系统感知进程存在的唯一标志——>进程与PCB是一一对应的

- 进程表：所有进程的PCB集合

### 3.2.4 进程控制
- **原子操作：** 进程控制操作完成进程各状态之间的转换，由具有特定功能的 **原语** 完成
    >原语：完成某种特定功能的一段程序，具有不可分割性或不可中断性，即原语的执行必须是连续的，在执行过程中不允许被中断
    1. 进程创建 create()
    2. 进程撤销 revoke()
    3. 阻塞 block()
    4. 唤醒 wakeup()
    5. 挂起 suspend()
    6. 激活 active()
    7. 进程终止 destroy()
    8. 改变进程优先级 renice()

## 3.3 进程调度

### 3.3.1 调度的基本概念
- 进程调度：即处理机调度（CPU调度）——其任务是控制、协调进程对CPU的竞争，按一定的调度算法从就绪队列中选择一个进程，把CPU的使用权交给被选中的进程【ps：如果没有就绪进程，系统会安排一个 **系统空闲进程**
】

- 系统场景
    - N个进程就绪，等待上CPU运行
    - M个CPU，M≥1
    - 需要决策：给哪一个进程分配哪一个CPU

- 进程调度要解决的三个问题
    1. WHAT：按什么原则选择下一个要执行的进程（ **调度算法** ）
    2. WHEN：何时进行选择（ **调度时机** ）
    3. HOW：如何让被选中的进程上CPU运行（ **调度过程** ）

### 3.3.2 进程调度算法
>调度算法衡量指标
>- 吞吐量：每单位时间完成的进程数目
>- 周转时间：每个进程从提出请求到运行完成的时间
>- 响应时间：从提出请求到第一次回应的时间
>- 其他：
>   - CPU利用率：CPU做有效工作的时间比例
>   - 等待时间：每个进程在就绪队列中等待的时间

1. 先进先出算法（FIFO，先来先服务）
2. 优先级调度算法（非抢占式优先级——固定优先级）
3. 时间片轮转调度算法

## 3.4 线程的基本概念

### 3.4.1 线程的引入
>进程的两项功能：使多个程序并发执行以改善资源利用率及提高系统的吞吐量

>将进程的上述两个功能分开，即作为调度和分派的基本单位，不同时作为独立分配资源的单位；对拥有资源的单位，不对之进行频繁切换——>线程因而产生

### 3.4.2 线程的定义和属性
1. 线程的定义：线程是进程的一个实体，是被系统独立调度和分派的基本单位。

2. 线程的属性
    - 有标识符ID
    - 有状态及状态转换——>需要提供一些操作
    - 不运行时需要保存的上下文
    >有上下文环境：程序计数器等寄存器
    - 有自己的栈和栈指针
    - **共享所在进程的地址空间和其他资源**
    - 可以创建、撤销另一个线程
>程序开始是以一个单线程进程方式运行的

# 第四章 进程同步与通信

## 4.1 进程间的相互作用

### 4.1.1 进程间的联系
- 进程互斥
    - 由于各进程要求使用共享资源（变量、文件等），而这些资源需要排他性使用
    各进程之间竞争使用这些资源
    ——这一关系成为进程互斥
    - 临界资源：
    系统中某些资源一次只允许一个进程使用，称这样的资源为 **临界资源** 或 **互斥资源** 或 **共享变量**
    - 临界区（互斥区）：
    各个进程中对某个临界资源（共享变量）实施操作的程序片段

- 进程同步：指系统中多个进程中发生的事件存在 **某种时序关系** ，需要相互合作，共同完成一项任务。（具体的说，一个进程运行到某一点时，要求另一伙伴进程为它提供消息，在未获得消息之前，该进程进入阻塞态，获得消息后被唤醒进入就绪态）

### 4.1.2 利用软件方法解决进程互斥问题
### 4.1.3 利用硬件方法解决进程互斥问题

### 4.1.4 信号量机制
- 信号量及P、V操作(是一种卓有成效的进程同步机制)
    >- 一个特殊变量
    >- 用于进程间传递信息的一个整数值
    >- 定义如下：
    ```C++
    struct semaphore
    {
        int count;
        queueType queue;
    }
    ```
    >- 信号量说明：semaphore  s;
    >- 对信号量可以实施的操纵：初始化、P和V
    >- P、V操作定义
    >   **wait(s)=P(s)** ，每次的wait操作意味着进程请求一个单位的资源
    >   **signal(s)=V(s)**，每次的signal操作表示执行进程释放一个单位的资源
    ```C++
    P(s){
        s.count--;
        if(s.count < 0){
            该进程状态置为阻塞状态；
            将该进程插入相应的等待队伍s.queue末尾；
            重新调度；
        }
    }

    V(s){
        s.count++;
        if(s.count <= 0){
            唤醒相应等待队列s.queue中等待的一个进程；
            改变其状态为就绪态，并将其插入就绪队列；
        }
    }   
    ```

## 4.2 进程通信
>为什么需要通信机制?
>- 信号量及管程的不足
>- 不适用多处理器情况（适用于：基于网络的分布式系统、基于共享内存的多处理机系统、单处理机系统，可以解决进程之间的同步（互斥）问题，通信问题）

>消息传递
>发送进程send(destination,message)  message:text,size
>接受进程receive(source,message)    message:text,size

## 4.3 死锁
### 4.3.1 死锁的基本概念
1. 死锁的定义
- 一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到的资源，这种现象称为 **进程死锁**，这一组进程就称为 **死锁进程**
- 如果死锁发生，会浪费大量系统资源，甚至导致系统崩溃
>- 参与死锁的所有进程都在等待资源
>- 参与死锁的进程是当前系统中所有进程的子集

2. 产生死锁的必要条件
- 互斥使用（资源独占）：一个资源每次只能给一个进程使用
- 占有且等待（请求和保持，部分分配）：进程在申请新的资源的同时保持对原有资源的占有
- 不可抢占（不可剥夺）：资源申请者不能强行的从资源占有者手中夺取资源，资源由占有者自愿释放
- 循环等待：存在一个进程等待队列{P1,P2,P3,...,Pn}，其中P1等待P2占有的资源，P2等待P3占有的资源，……，Pn等待P1占有的资源，形成一个进程等待环路

3. 解决死锁的基本方法
    - **不考虑此问题（鸵鸟算法）**
    - **不让死锁发生**
    1. 预防死锁（静态策略）：设计合适的资源分配算法，不让死锁发生
    2. 避免死锁（动态策略）：以不让死锁发生为目标，跟踪并评估资源分配过程，根据评估结果决策是否分配
    - **让死锁发生**
    3. 检测死锁
    4. 解除死锁

### 4.3.2 预防死锁
定义：
- 在设计系统时，通过确定 **资源分配算法**，排除发生死锁的可能性
- 具体的做法是：防止产生死锁的四个必要条件中任何一条发生

1. **破坏“循环等待”条件**
通过定义资源类型的线性顺序实现
实施方案：资源有序分配法（把系统中所有资源编号，进程在申请资源时必须严格按资源编号的递增次序进行，否则操作系统不予分配。）
实现时要考虑什么问题呢？
例子：解决哲学家就餐问题

2. **破坏“占有且等待”条件**
实现方案1：要求每个进程在运行前必须一次性申请，它所要求的所有资源，且仅当该进程所要资源均可满足时才给予一次性分配（✔问题：资源利用率低；“饥饿”现象）
实现方案2：在允许进程动态申请资源前提下规定，一个进程在申请新的资源不能立即得到满足而变为等待状态之前，必须释放已占有的全部资源，若需要再重新申请

### 4.3.3 避免死锁
>安全序列
>- 一个进程序列{P1,P2,P3,...,Pn}是安全的，如果对于每一个进程Pi（1≤i≤n）：它以后还需要的资源量不超过 **系统当前剩余的资源量与所有进程 Pj ( j < i )当前占有资源量之和** ，则称系统处于 **安全状态**
>- **安全状态一定没有死锁发生**

**银行家算法（重点）**
可利用资源向量Available
最大需求矩阵Max
分配矩阵Allocation
需求矩阵Need

### 4.3.4 检测死锁
时机：
1. 当进程由于资源请求不满足而等待时检测死锁
2. 定时检测
3. 系统资源利用率下降

### 4.3.5 解除死锁
1. 撤销所有死锁进程
2. 进程回退再启动
3. 按某种原则逐一撤销死锁进程

# 第五章 存储器管理

## 5.1 概述
### 5.1.1 存储体系
存储器一般分为主存储器（主存，内存）和辅助存储器（外存）
存储管理主要是对内存的管理，同时涉及对内存和外存的交换信息的管理。
内存可以分为系统区和用户区两个部分，系统区用来存储操作系统等系统软件，用户区用于分配给用户程序使用，存储管理实际上是对用户区的管理

### 5.1.2 存储管理的目的
为用户提供方便、安全和充分大的存储空间
✔方便：将逻辑地址与物理地址分开
✔安全：同时驻留在内存的多个用户进程互不干扰
✔充分大的存储空间：利用虚拟存储技术，逻辑上对内存空间进行扩充

### 5.1.3 存储管理的任务
基本概念：
>地址重定向
>- 进程中的地址不是最终的物理地址
>- 在进程运行前无法计算出物理地址（因为不能确定进程被加载到内存什么地方）
>**需要地址重定位的支持**【地址转换、地址变换、地址翻译、地址映射】

>逻辑地址（相对地址，虚拟地址）
>用户程序经过编译、汇编后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余地址都相对于首地址而编址
>**不能用逻辑地址在内存中读取信息**

>物理地址（绝对地址，实地址）
>内存中存储单元的地址   **可直接寻址**

>为了保证CPU执行指令时可正确访问内存单元，需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址，这一过程称为 **地址重定位**

>静态重定位与动态重定位
>>- 静态重定位
>>当用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换（**一般可由软件完成**）
>>- 动态重定位
>>在进程执行过程中进行地址变换（**需要硬件部件支持**）

### 5.1.5 存储管理方式的分类
存储管理方式可以分为连续分配方式和离散分配方式两大类
$$
存储管理方式\begin{cases}
            连续分配方式\begin{cases}
                            单一连续分配    \\
                            分区分配\begin{cases}
                                    固定分区    \\
                                    可变分区
                                    \end{cases}
                        \end{cases}  \\
            离散分配方式\begin{cases}
                            分页    \\
                            分段    \\
                            段页式
                        \end{cases}  \\
            覆盖技术    \\
            交换技术    \\ 
            虚拟存储器管理\begin{cases}
                            分页    \\
                            分段
                        \end{cases}
            \end{cases}
$$

## 5.2 连续存储管理方式
连续分配方式可以分为单一连续分配方式和分区分配方式，分区分配方式又可分为固定分区和可变分区。

### 5.2.1 单一连续分配
最简单，只能用于单用户、单任务的操作系统中。内存的用户区一次只分配给一个用户程序使用。

### 5.2.2 分区分配
1. 固定分区（设有固定分区表）
指系统预先把内存中的用户区分成若干个连续的分区，每个区域称为一个“分区”。各分区的大小可以相同，也可以不同。

2. 可变分区（分区长度、个数不固定）
动态划分内存空间
数据结构（已分分区表，空闲分区表）【分区序号+分区大小+分区起始地址】
>分区分配算法：
>1. 首次适应算法：从链首开始顺序查找
>>缺点是低地址部分不断被划分，致使留下许多难以利用的、很小的空闲分区，称为 **内存碎片**
>2. 循环首次适应算法：不再从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找
>>能使内存中的空闲分区分布地更均匀，减少查找空闲分区的开销，但这会导致缺乏大的空闲分区
>3. 最佳适应算法：每次为程序分配内存时，总是把既能满足要求、又是最小的空闲分区分配给程序，避免大材小用。要求将所有的空闲区，按其分区大小以递增的顺序形成一空闲分区链
>>每次分配后所切割下的剩余部分总是最小的，最容易形成内存碎片
>4. 最差适应算法：每次为程序分配内存时，总能找到一个满足程序长度要求的最大空闲分区进行分配
>>适合中、小程序运行，但对大程序的运行来讲是不利的

>分区回收算法
>1. 上相邻:回收区与前一个分区（空闲区）相邻，则合并
>2. 下相邻：回收区与后一个分区（空闲区）相邻，则合并
>3. 上下都相邻：回收区与前一个、后一个分区（空闲区）相邻，则合并三个分区
>4. 上下都不相邻

>可变分区分配的优点：
>>1. 有助于多道程序设计，提高了内存的利用率 
>>2. 要求硬件少，代价低。因为存储保护只需上、下限寄存器越界检查机构，或者是基址、长度寄存器，动态地址变换机构
>>3. 管理算法简单，实现容易
>
>可变分区分配的缺点：
>>1. 必须给程序分配一个连续的内存区域。有时虽然内存中所有空闲区的总和可以容纳一个程序，但没有一个空闲区可容纳这个程序
>>2. 碎片问题严重，内存仍不能得到充分利用
>>3. 不能实现对内存的扩充。分区的大小收到存储器容量的限制

3. 紧凑
为了解决内存碎片问题，可采用的一种方法是将内存中的所有进程进行移动，使他们相邻接。这种通过移动，把多个分散的小分区拼接成大分区的方法称为“紧凑”或“拼接”

## 5.3 覆盖技术和交换技术
### 5.3.1 覆盖技术（主要用于早期的操作系统）
- 解决的问题：程序大小超过物理内存总和
- 程序执行过程中，程序的不同部分在内存中相互替代
    >按照其自身的逻辑结构，将那些不会同时执行的程序段共享同一块内存区域
    >要求程序各模块之间有明确的调用结构
- 程序员声明覆盖结构，操作系统完成自动覆盖
- 缺点：对用户不透明，增加了用户负担

### 5.3.2 交换技术（运用于早期的小型分时系统的存储管理）
具有交换功能的操作系统，通常把外存分为文件区和交换区。文件区用于存放文件，交换区用于存放从内存中换出的程序（进程）。
- 文件都是较长时间存放在外存中，所以对文件区管理的主要目的是提高存储空间（磁盘）的利用率，故对文件区采用离散分配方式。
- 在交换区的程序驻留时间是短暂的，交换操作又较为频繁，所以对交换区管理的主要目的是提高程序的换入换出速度，故对交换区采用连续分配方式。

>同覆盖技术一样，交换技术也是利用外存来逻辑扩充内存。主要特点：打破了一个程序一旦进入内存便一直运行到结束的限制。

## 5.4 分页存储管理方式（为了减少内存碎片，提高内存空间的利用率）
根据在离散分配时所分配地址空间的基本单位的不同，离散分配分为以下三种方式：
1. **分页存储管理方式**。将用户程序的任一页放入任一物理块中，实现分散分配。
2. **分段存储管理方式**。将用户程序的地址空间分为若干个大小不同的段，以段为单位实现分散分配。
3. **段页存储管理方式**。分页和分段两种存储管理方式相结合的产物。

### 5.4.1 基本思想（工作原理）
1. 页面
>把一个进程的逻辑地址空间分为若干个大小相等的片，每个片称为页面或页。从0开始编号。
>页面的大小应选择适中，一般页的大小为2的幂，通常为 512B ~ 8KB

2. 逻辑地址
>分页存储管理逻辑地址分为两部分：地址的高位部分为页号，低位部分为页内位移。
>例如：逻辑地址32位，页大小4K，则页内位移占12位，页号占20位

3. 物理块（页框）
>把主存的物理地址空间分为和页面大小相等的区，每个区称为物理块或页框。从0开始编号。

4. 物理地址：块号+块内位移
5. 分页存储管理基本原理：
>以页为单位进行分配。当一个进程转入内存时，将进程的多个页面分别装入内存的多个物理块中，这些物理块可以是不相邻的。

```
硬件能自动分离出页号和页内地址，但我们只能通过计算才能得到。计算时要注意：
(1)逻辑地址以十六进制、八进制、二进制的形式给出
将逻辑地址转换成二进制的数；
按页的大小分离出页号和页内地址（低位部分是页内地址，高位部分是页号）；
根据题意产生页表；
将页内地址直接复制到物理地址的低位部分；
以页号查页表，得到对应页装入内存的块号，并将块号转换成二进制数填入地址的高位部分，从而形成内存物理地址。
```
### 5.4.3 快表
地址变换机构中增设了一个具有并行查询能力的特殊高速缓冲存储器

### 5.4.5 分配与回收
采用 **位示图** 的方式，即用一位来表示一块内存块，用一位的两种状态来表示内存块是空闲还是已分配。
>假定内存中共有3200个物理块可用来存储信息。如果用字长为32位的字来构造位示图，共需100个字。
>>计算位示图中第i个字的第j位对应的物理块号为：
>>>$块号=i*位示图中的字长+j$
>>
>>计算每个物理块所对应的位在位示图中的位置第i字，第j位，并将该位置0
>>>$i=块号/位示图中的字长$
>>>$j=块号$%$位示图中的字长$ 

## 5.5 分段存储管理方式（满足用户（程序员）编程和使用上的要求）
应用程序通常是由若干程序段（模块）组成，例如由主程序段、子程序段、数据段等组成，每段具有完整的逻辑意义。在分页存储管理中，页面是信息的物理单位，与源程序不存在逻辑关系，也就难以实现以段为单位的共享、保护、动态链接等。

### 5.5.4 分页和分段的主要区别
- 分段是信息的逻辑单位，由源程序的逻辑结构所决定,用户可见
- 段长可根据用户需要来规定，段起始地址可从任何主存地址开始
- 分段方式中，源程序(段号,段内位移)经连结装配后地址仍保持二维结构
$$
\Downarrow
$$
- 分页是信息的物理单位，与源程序的逻辑结构无关，用户不可见
- 页长由系统确定，页面只能以页大小的整倍数地址开始
- 分页方式中，源程序(页号,页内位移)经连结装配后地址变成了一维结构

# 第六章 虚拟存储器管理
## 6.1 概述
### 6.1.1 程序局部性原理（1968年美国Denning提出）
程序在执行时呈现出高度的局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域。
√时间局部性
一条指令被执行后，那么它可能很快会再次被执行，典型原因是程序中的循环。
√空间局部性
若某一存储单元被访问，那么与该存储单元相邻的单元可能也会很快被访问,典型原因是程序的顺利执行。

>局部性原理使得虚拟存储技术的实现成为可能。一个程序特别是一个大型程序的一部分装入内存是可以运行的。

>基于程序局部性原理，就没有必要把一个作业一次性全部装入内存再开始运行。

虚拟存储器的特征:
- √可以把一个程序分多次装入内存，每次装入当前运行需要使用的部分——多次性
- √在程序执行过程中，可以把当前暂不使用的部分换出内存，若以后需要时再换进内存——交换性即非驻留性
- √程序在内存中可分段存放，每一段是连续的——离散性
- √虚拟存储器还有一个最重要的特征——虚拟性，从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量

## 6.2 分页虚拟存储管理
### 6.2.1 基本原理
- 页表
为了实现请求分页技术，页表应增加相应的内容，反映该页是否在内存，在外存的位置，在内存的时间的长短等。
包括以下内容：物理块号、状态位、访问位、修改位、外存地址。

页号 | 物理块号 | 状态位 | 修改位 | 访问位 | 外存地址
---- |---------| ------ | -----  | ----- | -------

状态位：指示该页是否在内存
修改位：指示该页调入内存后是否修改
访问位：记录该页被访问的次数，或者最近已有多长时间未被访问，供选择换出页面时参考。
外存地址：指示该页在外存上的地址。

### 6.2.2 缺页中断机构
- 缺页中断与一般中断的异同
    - 相同点：保护现场、中断处理、恢复现场
    - 不同点：
        - 缺页中断是在一条指令执行期间产生和处理中断，一般中断是一条指令完成后CPU检查是否有中断;
        - 一条指令执行时可能产生多次缺页中断。如指令可能访问多个内存地址，这些地址在不同的页中。

### 6.2.4 页面置换算法题：
```
        1   3   2   1   1   3   5   1   3   2   1   5
======================================================
FIFO    1   3   2   2   2   2   5   1   3   2   2   5
        *   1   3   3   3   3   2   5   1   3   3   2
        *   *   1   1   1   1   3   2   5   1   1   3
======================================================
        ×   ×   ×   ✔   ✔  ✔   ×   ×   ×   ×   ✔   ×

缺页次数=8次，缺页率=8/12≈66.7%，淘汰顺序 1 3 2 5 1

        1   3   2   1   1   3   5   1   3   2   1   5
======================================================
OPT     1   3   2   2   2   2   5   5   5   5   5   5
        *   1   3   3   3   3   3   3   3   2   2   2
        *   *   1   1   1   1   1   1   1   1   1   1
======================================================
        ×   ×   ×   ✔   ✔  ✔   ×   ✔  ✔   ×   ✔  ✔

缺页次数=5次，缺页率=5/12≈41.7%，淘汰顺序 2 3

        1   3   2   1   1   3   5   1   3   2   1   5
======================================================
LRU     1   3   2   1   1   3   5   1   3   2   1   5
        *   1   3   2   2   1   3   5   1   3   2   1
        *   *   1   3   3   2   1   3   5   1   3   2
======================================================
        ×   ×   ×   ✔  ✔   ✔   ×   ✔  ✔   ×   ✔   ×

缺页次数=6次，缺页率=6/12=50%，淘汰顺序 2 5 3

```

### 6.2.7 抖动问题
- 抖动现象
在虚存中，页面在内存与外存之间频繁调度，以至于调度页面所需时间比进程实际运行的时间还多，此时 **系统效率急剧下降** ，甚至导致系统崩溃。这种现象称为 **颠簸或抖动**。
例如，一个每隔几条指令就发生一次页面故障的进程称为在颠簸（因为一条指令的执行只需几纳秒，而每从磁盘上读入一个页面则常需几十毫秒）。
- 系统发生抖动的原因
    1. 页面置换算法不合理
    2. 分配给进程的物理页面数太少

## 6.3 分段虚拟存储器
### 6.3.1 基本原理
分段虚拟存储管理原理同分页虚拟存储管理原理一样，在程序运行前，不必调入所有分段，只需先调入若干个分段便可启动运行。
当所访问的段不在内存中时，可请求操作系统将所缺的段调入内存。
分段虚拟存储管理中的段表包括：段名、段长、段的基址、存取方式、访问位、修改位、存在位、增补位和外存地址。

# 第七章 用户接口管理
## 7.1 概述
$$
\begin{cases}
命令接口    \begin{cases}
            联机命令接口    \\
            脱机命令接口
            \end{cases}\\
程序接口(API)    \\
图形接口
\end{cases}
$$
## 7.3 系统调用
系统调用是操作系统提供给编程人员的唯一接口
### 7.3.1 系统调用的概念
由操作系统提供，用户程序可以调用的包含特权指令的子程序称为“系统功能调用”程序，或简称为“系统调用”。

>*系统调用分类*
>1. 文件操作类
>2. 进程控制类：包括创建进程和中止进程、获得和设置进程属性、等待某事件出现等。
>3. 资源申请类
>4. 进程通信类
>5. 信息维护类

>*系统调用与一般过程调用的区别*
>系统调用通过非特权指令——访管指令调用
>>**✔系统调用通过软中断进入**
>>>一般的过程调用可直接由调用过程转向被调用过程；系统调用通常都是通过软中断机制转向相应的命令处理程序
>>>
>>**✔运行在不同的处理器状态**
>>>一般的过程调用，其调用程序和被调用程序都运行在相同的处理器状态；系统调用程序运行在目态，而被调用程序则运行在管态
>>>
>>**✔处理器状态的转换不同**
>>>一般的过程调用不涉及系统状态的转换；系统调用需要系统状态转换
>>>
>>**✔返回问题不同**
>>>一般的过程调用在被调用过程执行完后，将返回到调用过程继续执行；系统调用不一定返回原调用过程
>>>
>>**✔嵌套调用**
>>>像一般过程一样，系统调用也允许嵌套调用，但对嵌套调用的深度都有一定的限制

# 第八章 文件管理
## 8.1 概述
### 8.1.1 文件和文件系统
- 文件是什么
    - 文件是对磁盘的抽象
    - 所谓文件是指一组带标识（即文件名）、在逻辑上具有完整意义的信息集合（信息项序列）
    - 信息项：构成文件内容的基本单位（单个或多个字节），各信息项之间具有顺序关系
    - 文件内容的意义：由文件建立者和使用者解释

- 文件系统
    - 定义：操作系统中负责管理和存取文件信息的软件机构称为文件系统。它是由管理文件所需的数据结构和相应的管理软件以及访问文件的一组操作组成。

    - 功能：
        - 统一管理磁盘空间，实施磁盘空间的分配与回收
        - 实现文件的按名存取
        - 实现文件信息的共享，并提供文件的保护、保密手段
        - 向用户提供一个方便使用、易于维护的接口，并向用户提供有关统计信息
        - 提高文件系统性能
        - 提供与I/O系统的统一接口

## 8.2 文件的结构和存取方式
- 文件的组织结构
文件的组织结构是指文件的构造方式，用户和文件系统往往从不同的角度对待同一个文件。因此对于任何一个文件都存在两种形式的结构:
1. 用户的观点（文件的逻辑结构）：是研究用户“思维”中的抽象文件，或称逻辑文件，其研究的侧重点在于为用户提供一种逻辑结构清晰、使用简便的逻辑文件形式，用户将按照这种形式去存储、检索和加工有关文件中的信息。
>例如用户可将文件看作字符的集合，或者用户将文件看作记录的集合。
2. 实现的观点（文件的物理结构）：是研究驻留在存储介质上的文件，或称物理文件。文件在存储介质上是如何存放和组织的。它研究的侧重点是选择一些工作性能良好、设备利用率高的物理文件形式。

### 8.2.1 文件的存取方式
1. 顺序存取
2. 随机存取
3. 按键存取

### 8.2.2 文件的逻辑结构


### 8.2.4 文件的物理结构
磁盘文件的物理结构：
- 连续文件（顺序文件）
    - 优点：
        - 顺序访问容易速度快
    - 缺点：
        - 要求有连续的存储空间
        - 必须事先知道文件的长度
- 连接文件
    - 优点：
        - 提高了磁盘空间利用率，不存在外部碎片问题
        - 有利于文件插入和删除
        - 有利于文件的动态扩充
    - 缺点:
        - 存取速度慢，不适于随机存取
        - 可靠性问题，如指针出错
        - 更多的寻道次数和寻道时间
        - 链接指针占用一定的空间

- 索引文件
    - 优点：保持了连接文件的优点，又解决了其缺点
        - 既能顺序存取，又能随机存取
        - 满足了文件动态增长、插入删除的要求
        - 能充分利用磁盘空间
    - 缺点：
        - 较多的寻道次数和寻道时间
        - 索引表本身带来了系统开销（如：内存，磁盘空间，存取时间）

文件物理结构的比较
- 顺序文件的优点是不需要额外的空间开销，只要在文件目录项中指出文件的长度和首块的块号即可，对顺序的访问效率较高，适应于顺序存取。缺点是动态地增长系统开销较大；文件创建时要求用户提供文件的大小；存储空间浪费较大。
- 连接文件克服了连续文件的不足之处，但文件的随机访问系统开销较大，适应于顺序访问的文件
- 索引文件既适应于顺序存取，又适应于随机存取，是一种比较好的文件物理结构，但又有用于索引表的空间开销和文件索引的时间开销。UNIX系统是使用索引结构成功的例子
- 在当前流行的一些UNIX操作系统的版本中，同时支持顺序文件结构和索引文件结构
- DOS,Windows 系统支持FAT结构

## 8.3 文件目录
为了对文件实施有效的管理，需建立文件目录
文件目录管理应达到的要求：
1. **实现“按名存取”** ，即用户只须向系统提供需访问文件的名字，就能实现对文件的访问
2. **提高对目录的检索速度。** 通过合理组织目录结构，可加快对目录的检索速度
3. **文件共享**
4. **允许文件重名**

### 8.3.1 文件控制块（FCB）
为管理文件而设置的数据结构，保存管理文件所需的所有有关信息。（文件属性或元数据）
文件控制块是文件存在的标志，每个文件都有一个文件控制块。

>文件控制块的内容：
>1. 文件标识和控制信息：文件名、用户名、文件主存取权限、授权者存取权限、文件口令、文件类型等。
>2. 文件结构信息：文件逻辑结构、文件物理结构、文件所在设备名、记录个数、文件在物理存储介质中的位置等。
>3. 文件管理信息：共享文件的进程数、文件修改情况、文件最大长度、当前大小、文件建立日期、最近修改日期、最近访问日期、文件保留期限、记账信息等。

### 8.3.2 文件目录结构
文件目录、目录项与目录文件
- ✔文件目录
    - 统一管理每个文件的元数据，以支持文件名到文件物理地址
的转换
    - 将所有文件的管理信息组织在一起，即构成文件目录
- ✔目录文件
    - 将文件目录以文件的形式存放在磁盘上
- ✔目录项
    - 构成文件目录的基本单位
    - 目录项可以是FCB，（文件）目录是文件控制块（FCB）的有序集合

## 8.4 文件系统的实现
### 8.4.2 外存空间管理
文件管理要解决的重要问题之一是如何为新建的文件分配存储空间，其分配方法与内存有相似之处。
可采用连续分配方式和离散分配方式。不论采用哪种分配方式，都是以磁盘块作为基本分配单位。
为了实现存储空间分配，系统必须首先记住存储空间的使用情况，为此系统应设置相应的数据结构；其次系统应提供对存储空间进行分配和回收的手段。
下面介绍几种常用的文件存储空间的管理方法。

1. 空闲块表法（离散连续分配）：
>将所有空闲块记录在一个表中，即空闲块表
>主要两项内容：首（起始）块号、空闲块数
>表中每个登记项记录一组连续空闲块的首块号和块号，空闲块数为“0”的登记项为“空”登记项

首块号|空闲块数
-|-
2|4
18|2
25|3
...|...

>空闲块表属于连续分配，为每个文件分配连续的物理块，与内存的可变分区雷同。
>>分配回收算法:类似主存储器的可变分区管理方式
>>>存储空间分配：首次适应算法，最佳适应算法，最差适应算法
>>>存储空间回收：要考虑回收区前后是否有相邻空闲区，若有应合并

2. 空闲链表法：
    - 空闲盘块链：以盘块为基本元素构成一条链。分配时从链首开始，依次摘下适当数目的空闲盘块分配给用户，回收时将回收的盘块依次链入空闲盘块链。
        - 优点：分配、回收盘块过程简单
        - 缺点：空闲盘块链可能很长
    - 空闲盘区链：磁盘上的所有空闲盘区（每个盘区可能包含若干个盘块）链成一条链。分配方法与内存的动态分区分配类似，通常采用首次适应算法。在回收盘区时，同样也要将与回收区邻接的空闲盘区与之合并。
        - 优点：空间盘区链较短
        - 缺点：分配、回收盘区过程较复杂
3. 位示图法：由于磁盘被分块后，每一块的大小都是一样的，所以对每个磁盘可以用一张位示图指示磁盘空间的使用情况。
- 磁盘块的组织：
    一个磁盘的分块确定后，根据总块数决定位示图由多少字组成，位示图中的每一位与一个磁盘块对应，某位为“1”状态表示相应块已被占用，为“0”状态的位所对应的块是空闲块。
    位示图占用空间小，可将它保存在内存中，从而实现高速的物理块分配和回收。
    >计算位示图中第 i 个字的第 j 位对应的物理块号为：
    >$块号=i*位示图中的字长+j$
4. 成组连接法（Linux/UNIX）
（1）空闲块的组织
把空闲块分成若干组，把指向一组中各空闲块额指针集中在一起，每一组的第一个空闲块中登记下一组空闲块的块号和空闲块数

## 8.6 文件系统的安全性和数据一致性
影响文件安全性主要因素
1. **✔人为因素**
由于人们有意或无意的行为，而使文件系统中的数据遭到破坏、丢失或窃取
2. **✔系统因素**
由于系统的部分出现异常情况而造成对数据的破坏或丢失，特别是作为数据存储介质的磁盘在出现故障或损坏时，会对文件系统的安全性造成影响
3. **✔自然因素**
存放在磁盘上的数据，随着时间的推移而发生溢出或逐渐消失

### 8.6.1 防止人为因素造成的文件不安全性
文件保护机制
- 用于提供安全性、特定的操作系统机制
- 对拥有权限的用户，应该让其进行相应操作，否则，应禁止
- 防止其他用户冒充对文件进行操作

实现：用户身份验证+访问控制

1. 隐蔽文件和目录
系统和用户将要保护的文件目录隐蔽起来。在显示文件目录信息时由于不知道文件名而无法使用
2. 口令
文件口令：系统要求文件的建立者为他需要保密的文件设置一个口令
用户口令：当用户利用计算机终端使用计算机时使用
3. 文件加密
对于高度机密的文件，可采用加密码的措施。文件加密码是把文件中所有字符代码，按某种变换规则重新编码。文件的输入读出都经过编码程序和解码程序处理

### 8.6.2 防止系统因素或自然因素造成的文件不安全性
>文件系统的可靠性
>>可靠性：防御和预防各种物理性破坏和人为性破坏的能力

>坏块管理
>>软件办法：要求用户或文件系统构造一个包含全部坏块的文件
>>硬件方法：建立一个坏块表，在硬盘上为坏块表分配一个扇区，当控制器第一次被初始化时，它读坏块表并找一个空闲块（或磁道）代替有问题的块，并在坏块表中记录映射

>备份
>>1. 建立副本：把同一个文件保存到多个存储介质上，当某个文件损坏或丢失时，就可用其他存储介质上的备用副本来替换
>>2. 转储：海量转储、增量转储
>>>- 海量转储：定期将所有文件拷贝到后援存储器
>>>- 增量转储：只能增储修改过的文件，即两次备份之间的修改，减少系统开销
>>>- 物理转储：从磁盘第0块开始，将所有磁盘块按序输出到磁带
>>>- 逻辑转储：从一个或几个指定目录开始，递归地转储自给定日期后所有更改的文件和目录

### 8.6.3 文件系统的数据一致性
问题产生：
磁盘块->内存->写回磁盘块
若在写回之前，系统崩溃，则文件系统出现不一致

解决方案：
设计一个实用程序，当系统再次启动时，运行该程序，检查磁盘块和目录系统

一致性检查分为两种：
块的一致性检查+文件的一致性检查

## 8.7 磁盘调度
### 8.7.2 磁盘的移臂调度
当有多个访盘请求等待时，采用一定的策略，对这些请求的服务顺序调整安排
>目的：降低平均磁道服务时间，达到公平、高效
>>公平：一个I/O请求在有限时间内
>>高效：减少设备机械运动带来的时间开销

>一次访盘时间=寻道时间+旋转延迟时间+传输时间（减少寻道和延迟时间）

1. 先来先服务调度算法（FCFS）
根据访问请求的先后次序选择先提出访问请求的为之服务
优点：是磁盘调度的最简单的一种形式，它既容易实现，又公平合理
缺点：效率不高，相邻两次请求可能会造成最内到最外的柱面寻道，使磁头反复移动，增加了服务时间，对机械也不利

2. 最短查找时间算法（SSTF）
以磁头移动距离的大小作为优先的因素
优点：使靠近磁头当前位置的申请得到及时服务
缺点：没考虑磁头移动的方向，没考虑进程在队列中等待的时间；可能使移动臂不断花时间改变方向，还可能使一些离磁头较远的申请在较长时间内得不到服务

3. 扫描算法（SCAN）
选择请求队列中沿磁臂前进方向最接近于磁头所在柱面的访问请求作为下一个服务对象
优点：算法简单、实用且高效，克服了最短寻道优先的缺点，既考虑了距离，又考虑了方向
缺点：有时有的请求等待时间可能很长

# 第九章 设备管理
